## 哔哩哔哩java一面面经(48min)

手撕[算法]()：[二叉树的镜像]() 

> 之前PAT的时候做过, 依稀记得是用递归/栈

```cpp
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        postOrder(root);
        return root;
    }

    void postOrder(TreeNode *root){
        if ( root == nullptr ) return;
        postOrder(root->left);
        postOrder(root->right);
        swap(root->left, root->right);
    }

};
```



 死抠[项目]() 



 TCP三次握手和四次挥手 



 为什么握手要三次，挥手要四次 



 **虚拟地址和物理地址** 

物理地址-虚拟地址(段式管理下叫逻辑地址)

连续地址->线性地址

虚拟地址组成_32bit:  前10bit为页目录偏移; 中间10bit为页表偏移; 最后12bit为页内偏移。

页目录为4KB大小， 同时，在32位系统中, 每4字节byte(32bit) 就能存放一个地址， 因此一共能存放1024个地址

![虚拟地址](G:\CodingRecord\docs\faceExp\pics\虚拟地址.jpg)



[ 进程和线程的区别 ](https://www.yebaike.com/13/202008/447177.html)

- **根本区别**: 进程是<u>操作系统</u>资源分配的基本单位，而线程是<u>处理器</u>任务调度和执行的基本单位
- **资源开销**：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。
- **内存分配**：同一进程的线程共享本进程的<u>地址空间</u>和资源，而进程之间的地址空间和资源是相互独立的。
- **包含关系**：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。
- **影响关系**：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。
- **执行过程**：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行。

 进程间内存为什么不共享 



 HashMap 



 hash值的作用 



 除了拉链法解决冲突，还有什么方法吗，我说线性探测再散列等等 



 拉链法和线性探测法的优缺点呢 



 手撕[算法]()：给你一个无序数组，找出最大值和最小值，时间复杂度怎么算，要具体到多项式常数项那种，我做了一个2O(n）的，他问可以在O(n)时间内找出来吗——题目比较详细的描述：[无序数组中求最大值和最小值的最少比较次数](https://www.cnblogs.com/hugochen1024/p/12570824.html)， 解法：[找出最大值和最小值的时间复杂度比较小的一种方法](https://blog.csdn.net/xumesang/article/details/45072281)

```cpp
// 找到数组元素的最大值和最小值 
vector<int> findMinMax(vector<int> arr) {
    int min_ = INT_MAX,max_ = INT_MIN;
    // 处理前面偶数个元素
    for(int i=0;i< arr.size()/2 ;++i) {
        // 得到两个元素的最大值和最小值
        int tmp_min,tmp_max;
        if(arr[2*i] < arr[2*i+1]) {
            tmp_min = arr[2*i];
            tmp_max = arr[2*i+1];
        } else {
            tmp_min = arr[2*i+1];
            tmp_max = arr[2*i];
        }
        // 比较,更新最大值和最小值
        if(tmp_max > max_)  max_ = tmp_max;
        if(tmp_min < min_)  min_ = tmp_min;
        
        printf("arr[%d]: %d - arr[%d]: %d\n", 2*i, arr[2*i], 2*i + 1, arr[2*i+1]);
    }

    // 处理数组个数为奇数的情况 // 处理最后一个元素
    if(arr.size()%2) {
        int tmp = arr.back();
        if(tmp > max_)  max_ = tmp;
        if(tmp < min_)  min_ = tmp;
    }

    return {min_,max_};
}
```

## [哔哩哔哩 神奇的一面](https://www.nowcoder.com/discuss/129144?type=post&order=time&pos=&page=1&channel=1009&source_id=search_post&subType=2)

1.进程调度[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法) 
2.tcp三次握手 
3.多线程相关，说了一下线程池的东西 
4.数据库索引b 树 
5.给你一个[二叉树](https://www.nowcoder.com/jump/super-jump/word?word=二叉树)，求公共的根—— [LCA问题](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti-68-ii-er-cha-shu-de-zui-jin-gong-gon-7/)

[三数之和](https://leetcode-cn.com/problems/3sum/solution/san-shu-zhi-he-by-leetcode-solution/)

## [头条三面透心凉](https://www.nowcoder.com/discuss/109937?source_id=profile_create&channel=1009)

二面

**2.TCP和UDP的优缺点，TCP滑动窗口**

TCP的优点： 可靠，稳定 TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。 TCP的缺点： 慢，效率低，占用系统资源高，易被攻击 TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。

UDP的优点： 快，比TCP稍安全 UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。

TCP与UDP区别总结：

```
1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付
3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
5、TCP首部开销20字节;UDP的首部开销小，只有8个字节
6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道
```

**3.线程和进程切换，哪个快，两者有什么区别**

进程切换比线程切换开销大制是因为进程切换时要切页表，而且往往伴随着页调度，因为进程的数据段代码段要换出去，以便把将要执行的进程的内容换进来。本来进程的内容就是线程的超集。而且线程只需要保存线程的上下文（相关寄存器状态和栈的信息）就好了，动作很小

**4.代码是一个1-13张牌分牌（队列）**



三面

1.   mysql的主从（不了解） 
2.   线程之间的通信（我回答成了进程之间的，后来又强行答了一波） 
3.   linux的top（没听清）了解吗（不会） 
4.   tcp 的四次握手，timewait2的状态是什么情况，为什么会出现大量的timewait2？ 
5.   无序中位数找第K大的数字-> 内存是只能存1/3的数据怎么办



## 深信服Java岗面经（一面二面SP面）

Q:STL中vector 扩容为什么要以1.5倍或者2倍扩容？
在 VS 下是 1.5倍，在 GCC 下是 2 倍

## [渣硕秋招总结](https://www.nowcoder.com/discuss/500250?type=post&order=time&pos=&page=1&channel=1009&source_id=search_post)







## 知识点:

### 数据结构

#### 不同: 

**数组和[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)**

1. 存储空间上：数组在内存中是连续的，从栈中分配空间；链表是可以不连续的，从堆中分配空间。
2. 空间的使用上：链表对内存空间的利用率较高，可扩展性高；数组则不能，数组的空间大小是固定的，不适合动态存储，不方便动态添加。
3. 在查询，访问方式上：数组可以随机访问其中的元素，查找速度相对较快，链表则必须是顺序访问，不能随机访问。
4. 添加或删除元素时，数组比链表慢，因为数组要移动大量的元素，而链表只需修改指针即可。

**堆和栈的区别：**

1. 申请方式：stack由系统自动分配。 堆;需要程序员自己申请，并指明大小。 
2. 申请效率的比较：栈:由系统自动分配，速度较快。 堆:是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便. 
3. 申请大小的限制：栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M, 超出剩余空间会溢出。 堆的大小受限于计算机系统中有效的虚拟内存。 
4. 数据结构区别：堆可以被看成是一棵树，如：堆排序。栈：一种先进后出的数据结构。 
5. 缓存方式区别：栈使用的是一级缓存，它们通常都是被调用时处于存储空间中，调用完毕立即释放。 
   堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定。







### 锁相关知识

