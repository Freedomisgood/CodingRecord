## 哔哩哔哩java一面面经(48min)

手撕[算法]()：[二叉树的镜像]() 

> 之前PAT的时候做过, 依稀记得是用递归/栈

```cpp
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        postOrder(root);
        return root;
    }

    void postOrder(TreeNode *root){
        if ( root == nullptr ) return;
        postOrder(root->left);
        postOrder(root->right);
        swap(root->left, root->right);
    }

};
```



 死抠[项目]() 



 TCP三次握手和四次挥手 



 为什么握手要三次，挥手要四次 



###  **虚拟地址和物理地址** 

物理地址-虚拟地址(段式管理下叫逻辑地址)

连续地址->线性地址

虚拟地址组成_32bit:  前10bit为页目录偏移; 中间10bit为页表偏移; 最后12bit为页内偏移。

页目录为4KB大小， 同时，在32位系统中, 每4字节byte(32bit) 就能存放一个地址， 因此一共能存放1024个地址

![虚拟地址](G:\CodingRecord\docs\faceExp\pics\虚拟地址.jpg)



### [ 进程和线程的区别 ](https://www.yebaike.com/13/202008/447177.html)

- **根本区别**: 进程是<u>操作系统</u>资源分配的基本单位，而线程是<u>处理器</u>任务调度和执行的基本单位
- **资源开销**：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。
- **内存分配**：同一进程的线程共享本进程的<u>地址空间</u>和资源，而进程之间的地址空间和资源是相互独立的。
- **包含关系**：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。
- **影响关系**：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。
- **执行过程**：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行。

###  进程间内存为什么不共享 



###  HashMap 



###  hash值的作用 



###  除了拉链法解决冲突，还有什么方法吗，我说线性探测再散列等等 



###  拉链法和线性探测法的优缺点呢 



 手撕[算法]()：给你一个无序数组，找出最大值和最小值，时间复杂度怎么算，要具体到多项式常数项那种，我做了一个2O(n）的，他问可以在O(n)时间内找出来吗——题目比较详细的描述：[无序数组中求最大值和最小值的最少比较次数](https://www.cnblogs.com/hugochen1024/p/12570824.html)， 解法：[找出最大值和最小值的时间复杂度比较小的一种方法](https://blog.csdn.net/xumesang/article/details/45072281)

```cpp
// 找到数组元素的最大值和最小值 
vector<int> findMinMax(vector<int> arr) {
    int min_ = INT_MAX,max_ = INT_MIN;
    // 处理前面偶数个元素
    for(int i=0;i< arr.size()/2 ;++i) {
        // 得到两个元素的最大值和最小值
        int tmp_min,tmp_max;
        if(arr[2*i] < arr[2*i+1]) {
            tmp_min = arr[2*i];
            tmp_max = arr[2*i+1];
        } else {
            tmp_min = arr[2*i+1];
            tmp_max = arr[2*i];
        }
        // 比较,更新最大值和最小值
        if(tmp_max > max_)  max_ = tmp_max;
        if(tmp_min < min_)  min_ = tmp_min;
        
        printf("arr[%d]: %d - arr[%d]: %d\n", 2*i, arr[2*i], 2*i + 1, arr[2*i+1]);
    }

    // 处理数组个数为奇数的情况 // 处理最后一个元素
    if(arr.size()%2) {
        int tmp = arr.back();
        if(tmp > max_)  max_ = tmp;
        if(tmp < min_)  min_ = tmp;
    }

    return {min_,max_};
}
```

## [哔哩哔哩 神奇的一面](https://www.nowcoder.com/discuss/129144?type=post&order=time&pos=&page=1&channel=1009&source_id=search_post&subType=2)

### 1.进程调度[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法) 

### 2.tcp三次握手 

### 3.多线程相关，说了一下线程池的东西 

### 4.数据库索引b 树 

## [2021届校招B站-游戏事业部-后台开发工程师一面](https://www.nowcoder.com/discuss/484726?type=post&order=time&pos=&page=1&channel=1009&source_id=search_post)

1.自我介绍 

2.谈了研究生阶段的项目，聊了聊学习生活。  [这都是热身，随便聊聊，面试官人特别好。]

### 数据库：

1.数据库引擎的区别 
2.数据库的底层数据结构 
3.讲讲B+树 

### JVM：
Java内存结构

### 并发：

1.自旋锁是怎么实现的？[我还是没确定这个 实现原理 和 工作原理 是不是一回事]
2.死锁的原因
3.避免死锁的方法

### Java基础： 

1.instance of原理 
2.新建 java.lang.Integer可否加载？ 
3.同时新建两个 com.bilibili.Integer 可否加载？
4.引用类型 -> 四种引用 -> 引用区别 -> 引用的应用实例举例 

### 微服务：

了解吗？
分布式：
了解吗？ 

## [头条三面透心凉](https://www.nowcoder.com/discuss/109937?source_id=profile_create&channel=1009)

二面

**2.TCP和UDP的优缺点，TCP滑动窗口**

TCP的优点： 可靠，稳定 TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。 TCP的缺点： 慢，效率低，占用系统资源高，易被攻击 TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。

UDP的优点： 快，比TCP稍安全 UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。

### TCP与UDP区别总结：

```
1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付
3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
5、TCP首部开销20字节;UDP的首部开销小，只有8个字节
6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道
```

### **3.线程和进程切换，哪个快，两者有什么区别**

进程切换比线程切换开销大制是因为进程切换时要切页表，而且往往伴随着页调度，因为进程的数据段代码段要换出去，以便把将要执行的进程的内容换进来。本来进程的内容就是线程的超集。而且线程只需要保存线程的上下文（相关寄存器状态和栈的信息）就好了，动作很小

三面

1.   ### mysql的主从（不了解） 
2.   ### 线程之间的通信（我回答成了进程之间的，后来又强行答了一波） 
3.   ### linux的top（没听清）了解吗（不会） 
4.   ### tcp 的四次握手，timewait2的状态是什么情况，为什么会出现大量的timewait2？ 
5.   ### 无序中位数找第K大的数字-> 内存是只能存1/3的数据怎么办



## [深信服Java岗面经（一面二面SP面）](https://www.nowcoder.com/discuss/540011?type=post&order=time&pos=&page=1&channel=1009&source_id=search_post)

Q:STL中vector 扩容为什么要以1.5倍或者2倍扩容？
在 VS 下是 1.5倍，在 GCC 下是 2 倍

### 缓存雪崩 

###  布隆过滤器 

###  BIO NIO AIO 

###  ThreadLocal 

###  Hashmap 

###  Hashmap头插死循环的过程 

###  Hashmap插入的过程，null怎么处理 

###  为什么要重写Hashcode 和 equals方法，并且举出实例 

###  mysql 索引调优



### springboot比spring好在哪里 

###   Linux上锁的方法有哪些？ 

###   数据包经过交换机的时候会发生什么变化？ 

  （这个问题完全没看过，问我我只能说不会，然后他就说看来你除了java别的都不会，我当然不同意，挣扎了一下，你换个问题再问问？） 

  然后他问了 

###   有了mac地址为什么还要有ip地址？





## [渣硕秋招总结](https://www.nowcoder.com/discuss/500250?type=post&order=time&pos=&page=1&channel=1009&source_id=search_post)



## [百度C++ 一二三面](https://www.nowcoder.com/discuss/549359?type=post&order=time&pos=&page=1&channel=1009&source_id=search_post)

**百度一面** 

  1.TCP和UDP的区别 

  2.http和https的区别 

  3.进程和线程的区别 

  4.协程 

  5.查看文件夹下的文件权限 

  6.查看文件的最后五行 

  7.Innodb和其他存储引擎的区别 

  8.memory ， MyISAM，Innodb索引实现 

  9.最长不重复子串 

  10 .linux 的硬连接和软连接

**[百度]()二面** 

  1.实习做了哪些事情 

  2.线程池，reactor模式 

  3.io多路复用 epoll的水平触发和边缘触发 ，读的时候需要做什么考虑 

  4.[redis]()的通信模型 

  5.[redis]()事务的实现 

  6.watch key 怎么实现的 

  7.mysql 一条语句查询太慢怎么优化 

  8.mysql 优化器在选择的时候可能出现错误怎么处理 

  9.mysql 事务ACID 

  10.mysql 四个隔离级别分别怎么处理 

  11.MVCC 

  12.幻读如何解决 

  13.TCP为什么是三次握手 

  14.TCP 的 timewait  closewait状态 

  15.服务器如果出现大量timewait怎么处理 

  16.[redis]() 怎么实现高可用的 

  17. 实现id生成器，需要保证id不重复，高可用，防止宕机，多个[客户端]()会进行访问请求id 

  **[百度]()三面** 

  1.觉得自己和别人相比的优势在哪 

  2.在字节实习作出了哪些贡献 

3. [redis]() 是CAP三个原则都满足吗 

4. 软件测试怎么测试的有了解过吗，平时自己怎么进行测试 ，有没有写单测 

  5.学校实验室是干什么的 

  6.grep命令有了解吗 

  7.如果写一个脚本去找出一个文档里面开头是ABC的行怎么找 

  8.在校主持多次活动是主持哪些活动 

  9.说一个自己最近印象最深的一道题





## [B站/哔哩哔哩/bilibili后台开发工程师](https://www.nowcoder.com/discuss/489280?type=post&order=time&pos=&page=1&channel=1009&source_id=search_post&subType=2)

### 1.自我介绍

### 2.介绍一下你的websever

### 3. 是静态资源吗

### 4.[项目]()的难点是什么，怎么解决的

### 5.epoll+线程池，reactor模型（讲讲并发模型）

### 6.能解释一下沾包和拆包吗，以及为什么

### 7.TCP和UDP的区别，以及哪些协议是TCP的，哪些是UDP的

### 8.TCP的滑动窗口和拥塞窗口

### 9.怎么判断网络拥塞

### 10.除了超时重传还有其他判断方式吗

### 11.select和epoll的区别

### 12.HTTPS，单向认证

### 13.Linux的虚拟地址和物理地址

### 14.介绍一下Linux4G的布局是怎么样的

### 15.[LRU手撕一下，语言介绍一下，复杂度]()



## 知识点:

### 数据结构

#### 不同: 

**数组和[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)**

1. 存储空间上：数组在内存中是连续的，从栈中分配空间；链表是可以不连续的，从堆中分配空间。
2. 空间的使用上：链表对内存空间的利用率较高，可扩展性高；数组则不能，数组的空间大小是固定的，不适合动态存储，不方便动态添加。
3. 在查询，访问方式上：数组可以随机访问其中的元素，查找速度相对较快，链表则必须是顺序访问，不能随机访问。
4. 添加或删除元素时，数组比链表慢，因为数组要移动大量的元素，而链表只需修改指针即可。

**堆和栈的区别：**

1. 申请方式：stack由系统自动分配。 堆;需要程序员自己申请，并指明大小。 
2. 申请效率的比较：栈:由系统自动分配，速度较快。 堆:是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便. 
3. 申请大小的限制：栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M, 超出剩余空间会溢出。 堆的大小受限于计算机系统中有效的虚拟内存。 
4. 数据结构区别：堆可以被看成是一棵树，如：堆排序。栈：一种先进后出的数据结构。 
5. 缓存方式区别：栈使用的是一级缓存，它们通常都是被调用时处于存储空间中，调用完毕立即释放。 
   堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定。







### 锁相关知识







### 数据库

1. 索引优化:

2. 数据库优化

3. 索引的最左优先原则

4. 数据库左连、右连和内连

   左联：首先取出a表中所有数据,然后再加上与a,b匹配的的数据

   内联：两个表a,b相连接,要取出id相同的字段

   右联：指的是首先取出b表中所有数据,然后再加上与a,b匹配的的数据

5. 存储引擎以及他们之间的区别 

    **InnoDB**：提供了良好的事务处理、崩溃修复能力和并发控制。为了维护数据完整性，InnoDB还支持外键完整性约束。 

    支持自动增加列AUTO_INCREMENT（自动增长列）属性。InnoDB提供行级锁，大幅度提高了多用户并发操作的性能。 

    **缺点**是读写效率较差，占用的数据空间相对较大。使用场景，如：银行（对事务的完整性要求比较高），售票（要求实现并发控制）。 

    **MyISAM**：使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。 

    拥有较高的插入、查询速度，但不支持事物。基于MyISAM存储引擎的表支持3种不同的存储格式。包括静态型、动态型和压缩型。其中，静态型是MyISAM的默认存储格式，它的字段是固定长度的；动态型包含变长字段，记录的长度不是固定的；压缩型需要用到myisampack工具，占用的磁盘空间较小。

6. B+树

   B+树是在B树的基础上改造，它的数据都在叶子节点，同时，叶子节点之间还加了指针形成[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表).

   B+树所有的数据都在叶子节点，不用跨层，同时有[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)结构，只需要找到首尾，通过[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)就能把所有数据查询出来.

7. 数据库索引有哪些类型

8. 范式、第三范式

9. 全文索引跟其他索引的区别，怎么实现的

10. 查重复‘字段’，统计重复次数：`SELECT [字段],COUNT(0) AS重复次数FROM [表名] GROUP BY [字段] HAVING COUNT([字段]) > 1 order by重复次数`

11. 查找薪资第二高：`select (select DISTINCT Salary from Employee ORDER BY Salary DESC limit 1 offset 1) as Second；`



## Linux相关

- 一个文件夹目录，获取该目录下以’ppt‘结尾的文件：`find dir -name "*.txt"`

  查找目录：find /（查找范围）-name '查找关键字' -type d

  查找文件：find /（查找范围）-name查找关键字-print

  

  ### inux里source、sh、bash、./有什么区别 

  1、source：source a.sh，在当前shell内去读取、执行a.sh，而a.sh不需要有"执行权限" 

  2、sh/bash:打开一个subshell去读取、执行a.sh，而a.sh不需要有"执行权限".通常在subshell里运行的脚本里设置变量，不会影响到父shell的。





## 计算机网络

### 1、**SSL怎么加密的？** 

 非对称加密[算法]()：RSA，DSA/DSS 
 对称加密[算法]()：AES，RC4，3DES 
 HASH[算法]()：MD5，SHA1，SHA256 
 其中非对称加密[算法]()用于在**握手过程中加密**生成的密码，对称加密[算法]()用于对**真正传输的数据进行加密**，而HASH[算法]()用于**验证数据的完整性**。由于浏览器生成的密码是整个数据加密的关键，因此在传输的时候使用了非对称加密[算法]()对其加密。 
 非对称加密算***生成公钥和私钥，公钥只能用于加密数据，因此可以随意传输，而网站的私钥用于对数据进行解密，所以网站都会非常小心的保管自己的私钥，防止泄漏。

### 2、**HTTPS的具体流程** 

 1、浏览器将自己支持的一套加密规则发送给网站。 
 2、网站从中选出一组加密[算法]()与HASH[算法]()，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。 
 3、获得网站证书之后浏览器要做以下工作：a)验证证书的合法性b)如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。c)使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。 
 4、网站接收浏览器发来的数据之后要做以下的操作：a)使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。b)使用密码加密一段握手消息，发送给浏览器。 
 5、浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密[算法]()进行加密。 

###  **三次握手：** 

 1）发送端首先发送一个带有SYN标志地数据包给接收方。 
 2）接收方接收后，回传一个带有SYN/ACK标志的数据包传递确认信息，表示我收到了。 
 3）最后，发送方再回传一个带有ACK标志的数据包，代表我知道了，表示’握手‘结束。 

###  **四次挥手：** 

 1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。 
 2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。 
 3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。 
 4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。 

 **为什么是四次？**当被动方收到主动方的FIN报文通知时，它仅仅表示主动方没有数据再发送给被动方了。但未必被动方所有的数据都完整的发送给了主动方，所以被动方不会马上关闭SOCKET,它可能还需要发送一些数据给主动方后，再发送FIN报文给主动方，告诉主动方同意关闭连接，所以这里的ACK报文和FIN报文多数情况下都是分开发送的。 

###  **TCP与UDP区别总结：** 

 1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接 
 2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付. 
 3、TCP面向字节流，TCP把数据看成一连串无结构的字节流;UDP是面向报文的 
 UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等） 
 4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信 
 5、TCP首部开销20字节;UDP的首部开销小，只有8个字节 
 6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道 

###  **DHCP（动态主机配置协议）**

是一个局域网的网络协议。指的是由服务器控制一段lP地址范围，客户机登录服务器时就可以自动获得服务器分配的lP地址和子网掩码。采用udp传输。 
 1、DHCP Client以广播的方式发出DHCP Discover报文。 [ 
 2、所有的DHCP Server都能够接收到DHCP Client发送的DHCP Discover报文，所有的DHCP Server都会给出响应，向DHCP Client发送一个DHCP Offer报文。 
 3、DHCP Client只能处理其中的一个DHCP Offer报文。 
 4、DHCP Server收到DHCP Request报文后，判断选项字段中的IP地址是否与自己的地址相同。如果相同，DHCP Server就会向DHCP Client响应一个DHCP ACK报文 
 5、DHCP Client接收到DHCP ACK报文后，检查DHCP Server分配的IP地址是否能够使用 
 6、DHCP Client在成功获取IP地址后，随时可以通过发送DHCP Release报文释放自己的IP地址，DHCP Server收到DHCP Release报文后，会回收相应的IP地址并重新分配。



### **拥塞控制的场景以及解决方法（四种）。** 

 **一般原理**：发生拥塞控制的原因：资源(带宽、交换节点的缓存、处理机)的需求>可用资源。 
 **作用**：拥塞控制就是为了防止过多的数据注入到网络中，这样可以使网络中的路由器或者链路不至于过载。拥塞控制要做的都有一个前提：就是网络能够承受现有的网络负荷。 
 **对比流量控制**：拥塞控制是一个全局的过程，涉及到所有的主机、路由器、以及降低网络相关的所有因素。流量控制往往指点对点通信量的控制，是端对端的问题。 
 慢启动和拥塞避免：发送方维持一个叫做拥塞窗口cwnd，初始值为1，每经过一个传输伦次（RTT时间），cwnd加倍（指数增长），为了防止拥塞窗口cwnd增长过大而引起网络拥塞，设置一个慢开始门限ssthresh。 
 1.当cwnd       算法    
 2.当cwnd>ssthresh，停止使用慢开始，使用拥塞避免[算法]()（线性增长每次加一） 
 3.当cwnd==ssthresh，两者都可以使用 
 **快重传**：当接收方收到了一个失序的报文，马上报告给发送方，我没收到，赶紧重传。发送方一连收到三个重复的ACK,那么不必等待重传计时器到期，立即重传。 
 **快恢复**：当发送方连续收到三个重复确认，执行乘法减小，ssthresh减半。然后执行拥塞避免[算法]()，使拥塞窗口缓慢增大。



## JAVA基础相关

### **jvm的内存结构** 

 jvm内存共分为虚拟机栈，堆，方法区，程序计数器，本地方法栈 
 1，虚拟机栈：线程私有，每个方法在执行的时候会创建一个栈帧，存储了局部变量表，操作数帧，动态连接，方法返回地址等；每个方法从调用到执行完毕，对应一个栈帧在虚拟机中的出栈和入栈。 
 2，堆：线程共享，被所有线程共享的一块内存区域，在虚拟机启动时创建，用于存放对象实例。 
 3，方法区：线程共享；被所有线程共享的一块内存区域；用于存储已被虚拟机加载的类信息，常量，静态变量等。 
 4，程序计数器：线程私有，是当前线程所执行的字节码的行号指示器，每条线程都有一个独立的线程计数器，这类内存也被称为"线程私有"的内存。 
 5， 本地方法栈：线程私有；主要为虚拟机使用到的Native方法服务。 

###  **JVM中堆和栈的区别：** 

 1、最主要的区别就是栈内存用来存储局部变量和方法调用。 
 而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。 
 2、独有还是共享： 
 栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。而堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。 
 3、异常错误：如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError。而如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError。 
 4、空间大小：栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满。如果递归没有及时跳出，很可能发生StackOverFlowError问题。可以通过-Xss选项设置栈内存的大小。-Xms选项可以设置堆的开始时的大小，-Xmx选项可以设置堆的最大值。 

###  **控制反转（IoC），**获得依赖对象的方式反转 

 一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（反射，它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的）。 
 我的理解是，创建对象的控制权进行转移，以前创建对象的主动权和创建时机是由自己把控的，而现在这种权力转移到第三方，比如转移交给了IoC容器，它就是一个专门用来创建对象的工厂，你要什么对象，它就给你什么对象，有了IoC容器，依赖关系就变了，原先的依赖关系就没了，它们都依赖IoC容器了，通过IoC容器来建立它们之间的关系。 
 **aop：**可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。 

###  Java的内部类和静态内部类的区别？ 

###  线程的实现方式有哪些？ 

###  平常遇到过哪些异常？捕获异常有哪些方法？ 

  1. JVM(Java虚拟机)异常：由JVM抛出的异常或错误。例如：NullPointerException类，ArrayIndexOutOfBoundsException类，ClassCastException类。 
  2. 程序级异常：由程序或者API程序抛出的异常。例如IllegalArgumentException类，IllegalStateException类。

3、**Java多线程实现的方法，各自的优劣对比。** 

 1.继承Thread类，启动线程通过Thread类的start()实例方法。start()方法是一个native方法，它将启动一个新线程，并执行run()方法。优点：代码简单。缺点：该类无法继承别的类。 
 2.实现Runnable接口，优点：继承其他类。同一实现该接口的实例可以共享资源。缺点：代码复杂 
 3.实现Callable接口，通过FutureTask包装器来创建Thread线程：优点：可以获得异步任务的返回值 
 4.线程池：实现自动化装配，易于管理，循环利用资源。 

###  4、**接口和抽象类的区别。** 

1.  抽象类和接口都不能被实例化。 
2.  两者都是用来抽象具体对象的，但接口的抽象级别更高。 
3.  类可以实现多个接口，但只能继承一个抽象类。 

4. 抽象类可以有具体的属性和方法，但接口只能有抽象方法和不可变常量（定义的常量都是公共的静态常量，用final来修饰）。 

5. 抽象类可以用protected、public来修饰，但接口只能由public来修饰。 

6. 接口是设计的结果（注重功能实现），抽象类是重构的结果（实现代码复用）。 

###  5、**垃圾回收原理以及gc[算法]()（三种），复制[算法]()的原理。** 

 随着程序运行，内存中存在的实例对象、变量等信息占据内存越来越多，如果不及时进行垃圾回收，程序性能下降，甚至会由于内存不足出现系统异常。回收的时间点：（1）该类的实例对象都已被回收（2）加载该类的classloader已经被回收（3）该类对应的反射类java.lang.class对象没有被任何地方引用。 
 需要回收的区：堆和方法区。 
 常见的回收[算法]()：三个[算法]()都基于根搜索[算法]()去判断一个对象是否应该被回收，而支撑根搜索[算法]()可以正常工作的理论依据，就是语法中变量作用域的相关内容。 
 **（1）标记-清除[算法]()**：将进行回收的做标记，之后扫描清除。 
 **（2）复制[算法]()**：将内存划分为两个区间，在任意时间点，所有动态分配的对象都只能分配在其中一个区间（称为活动区间），而另外一个称为空闲区间。当有效内存空间耗尽时，JVM将暂停程序运行，开启复制[算法]()GC线程。接下来GC线程会将活动区间内的存活对象，全部复制到空闲区间，且严格按照内存地址依次排列，与此同时，GC线程将更新存活对象的内存引用地址指向新的内存地址。此时，空闲区间已经与活动区间交换，而垃圾对象现在已经全部留在了原来的活动区间，也就是现在的空闲区间。事实上，在活动区间转换为空间区间的同时，垃圾对象已经被一次性全部回收。 
 **（3）标记-整理[算法]()**：标记：遍历GC Roots，然后将存活的对象标记。整理：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。 

###  6、**Java深复制浅复制区别。** 

###  7、**Java并发控制实现方式。** 

###  8、**索引概念、使用位置及优化。** 







### 常见JAVA工具

#### jps

>  jps可以仅仅过滤出java本身的进程以及运行的引导类（引导main方法所在的类即入口类）

```shell
$sudo jps -l
# 进程ID  启动主方法所在类名
15086 org.jboss.Main
17576 sun.tools.jps.Jps
```

jps命令是基于Java实现的， 可以如VirutalMachine.list()拿到VirtualMachineDescriptor对象后输出id和displayNmae得到

▲. 在LINUX上可以通过`ps -ef|grep java`来查看JAVA进程

#### jstat(JVM统计监测工具)

> 一般用来定位问题，是比较快速初步定位的一种方式，可以用他看到<u>JVM每个区域</u>的情况， 根据不同的参数， 可以到每个区域的使用情况和比例

```shell
# 100ms采集一次数据, 一共采集2次
$jstat -gcutil <pid> 1000 2
  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   
  0.00  78.68  56.62  81.22  93.55  89.91   1989   12.192    39    4.231   16.423
  0.00  78.68  56.65  81.22  93.55  89.91   1989   12.192    39    4.231   16.423
# E表示Eden, O表示old, M表示method(特种兵书上是Perm永久代, 现在变成了方法区),  CCS 压缩类空间利用率为百分比, YGC表示Minor GC次数, YGCT表示MinorGC花费时间, GCT表示MinorGC和FullGC一共的GC总的时间
```



#### jmap

> jmap命令是一个可以输出所有内存中对象的工具，甚至可以将VM 中的heap，以二进制输出成文本。
> 打印出某个java进程（使用pid）内存内的，所有‘对象’的情况（如：产生那些对象，及其数量）。
>
> jmap(Memory Map)用来查看堆内存使用状况，一般结合jhat(Java Heap Analysis Tool)使用。

使用jmap -heap pid查看进程堆内存使用情况，包括使用的GC算法、堆配置参数和各代中堆内存使用情况。比如下面的例子：`jmap -heap 21711`(我的windows不能直接用), `jmap -histo <pid>`可以

#### jstack

>  jstack主要用来输出线程信息, 查看某个Java进程内的线程堆栈信息

 **jstack -F pid 检查是否有死锁**

```
$ jstack -l <pid>
```

#### MAT(memory analyzer tool)

> java内存分析工具, 分析的是JVM内存dump文件

#### jinfo

> 在JAVA进程运行的过程中, 我们可以通过jmap -heap命令来查看内存使用情况的基本信息, 但一些更为详细的参数情况获取不到, 例如输出以-xx:开头的参数。如果想看某些运行时参数甚至去做一些修改， 则可以使用jinfo

```shell
# 查看PrintGCDetails参数
$ jinfo -flag PrintGCDetails 9308
# 结果： -XX:-PrintGCDetails (负号表示没开)

# 修改参数
$ jinfo -flag +PrintGCDetails 9308
```



## 操作系统

###  进程间的通信方式。

###  **进程调度[算法]()。**







## Redis相关

缓存雪崩 
布隆过滤器 











### [python-list, tuple, dictionary, set的底层细节](https://blog.csdn.net/siyue0211/article/details/80560783)

### [python中可哈希对象是个啥？what is hashable object in python?](https://www.cnblogs.com/langqi250/p/10303759.html)











## 算法题记录

### LeetCode93-复原IP地址

```cpp

class Solution {
private:
    vector<string> ans;
    
public:
    vector<string> restoreIpAddresses(string s) {
        if ( s.size() > 12 ) return {};
        // 第一个dot不可能在首位
        BackTracking(s, 0, 1);
        return ans;
    }


    // 当前string, 已有dot数, dot位置
    void BackTracking(string s, int dot_num, int dot_position){
        if( dot_num == 3){
            if ( islegalIP(s) ){
                ans.push_back(s);
            }
            return ;
        }
        //
        for (int i = dot_position; i < s.size(); i++) {
           s.insert(i, ".");
           // dot不可能连续， 需要为 + 2
           BackTracking(s, dot_num + 1, i + 2);
           // 从i位置删除一个字符
           s.erase(i, 1);
        }
    }
    
    bool islegalIP(string s){
        if ( s.size() > 12 + 3) return false;
        for (int i = 0; i < s.size(); i++) {
            // 遇到.前的数
            int tmp = 0;
            // 起点
            int j = i;
            while( i < s.size() && s[i] != '.'){
                tmp = tmp * 10 + s[i++] - '0' ;
                if( tmp > 255) return false;
            }
            // 不用+1, 因为此时i在dot的位置
            int delta = i - j;
            // 去前导0的情况
            if ( delta > 3 || ( delta == 3 && tmp < 100 ) || (delta == 2 && tmp < 10)){
                return false;
            }
        }
        return true;    
    }
};

```



### **4.代码是一个1-13张牌分牌（队列）**

### 5.给你一个[二叉树](https://www.nowcoder.com/jump/super-jump/word?word=二叉树)，求公共的根—— [LCA问题](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti-68-ii-er-cha-shu-de-zui-jin-gong-gon-7/)

### [三数之和](https://leetcode-cn.com/problems/3sum/solution/san-shu-zhi-he-by-leetcode-solution/)















